#!/bin/bash

#===============================================================================
# mole - SSH Tunnel Control for Mac
#===============================================================================
set -e

readonly VERSION="1.0.0"
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m'

readonly PLIST_LABEL="com.robfz.mole"
readonly PLIST_PATH="$HOME/Library/LaunchAgents/${PLIST_LABEL}.plist"
readonly LOG_FILE="/tmp/ssh-tunnel.log"
readonly ERR_FILE="/tmp/ssh-tunnel.err"

# Options
LOG_LINES=10
VERBOSE=false

#===============================================================================
# Utility Functions
#===============================================================================
status_ok() {
    echo -e "  ${GREEN}✓${NC} $1"
}

status_warn() {
    echo -e "  ${YELLOW}⚠${NC} $1"
}

status_fail() {
    echo -e "  ${RED}✗${NC} $1"
}

status_info() {
    echo -e "  ${BLUE}ℹ${NC} $1"
}

print_header() {
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}  SSH Tunnel Status (Mac)${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
}

print_usage() {
    cat << EOF
Usage: $(basename "$0") <command> [OPTIONS]

Control and monitor the SSH tunnel service.

Commands:
  start              Start the tunnel
  stop               Stop the tunnel
  restart            Restart the tunnel
  status             Show tunnel status

Options (for status):
  -v, --verbose      Detailed output with logs and troubleshooting
  -l, --log-lines N  Number of log lines to show (default: 10, implies -v)

General:
  -h, --help         Show this help message
  --version          Show version

Examples:
  $(basename "$0") start
  $(basename "$0") status
  $(basename "$0") status -v
  $(basename "$0") status -v -l 20
EOF
}

check_plist() {
    if [ ! -f "$PLIST_PATH" ]; then
        status_fail "Tunnel not configured. Run setup-tunnel-mac.sh first."
        exit 1
    fi
}

is_running() {
    pgrep -f "autossh" > /dev/null 2>&1
}

#===============================================================================
# Control Commands
#===============================================================================
cmd_start() {
    check_plist
    
    if is_running; then
        status_info "Tunnel is already running"
        return 0
    fi
    
    launchctl load "$PLIST_PATH" 2>/dev/null
    sleep 2
    
    if is_running; then
        status_ok "Tunnel started"
    else
        status_fail "Failed to start tunnel. Check: tail -f $LOG_FILE"
        exit 1
    fi
}

cmd_stop() {
    check_plist
    
    if ! is_running; then
        status_info "Tunnel is not running"
        return 0
    fi
    
    launchctl unload "$PLIST_PATH" 2>/dev/null
    
    # Also kill any lingering processes
    pkill -f "autossh" 2>/dev/null || true
    pkill -f "caffeinate.*autossh" 2>/dev/null || true
    
    sleep 1
    
    if is_running; then
        status_fail "Failed to stop tunnel"
        exit 1
    else
        status_ok "Tunnel stopped"
    fi
}

cmd_restart() {
    check_plist
    
    status_info "Restarting tunnel..."
    
    # Stop
    launchctl unload "$PLIST_PATH" 2>/dev/null || true
    pkill -f "autossh" 2>/dev/null || true
    pkill -f "caffeinate.*autossh" 2>/dev/null || true
    sleep 1
    
    # Start
    launchctl load "$PLIST_PATH" 2>/dev/null
    sleep 2
    
    if is_running; then
        status_ok "Tunnel restarted"
    else
        status_fail "Failed to restart tunnel. Check: tail -f $LOG_FILE"
        exit 1
    fi
}

#===============================================================================
# Status Command
#===============================================================================
check_launchd_service() {
    echo -e "${BLUE}Launchd Service:${NC}"
    
    # Check if plist exists
    if [ -f "$PLIST_PATH" ]; then
        status_ok "Plist file exists: $PLIST_PATH"
    else
        status_fail "Plist file not found: $PLIST_PATH"
        return
    fi
    
    # Check if service is loaded
    if launchctl list | grep -q "$PLIST_LABEL"; then
        status_ok "Service is loaded in launchd"
        
        # Get detailed status
        local exit_status
        exit_status=$(launchctl list | grep "$PLIST_LABEL" | awk '{print $1}')
        if [ "$exit_status" = "-" ]; then
            status_ok "Service is running (no exit code)"
        elif [ "$exit_status" = "0" ]; then
            status_warn "Service exited with code 0 (may have stopped)"
        else
            status_fail "Service exited with code: $exit_status"
        fi
    else
        status_fail "Service is not loaded in launchd"
    fi
    echo ""
}

check_processes() {
    echo -e "${BLUE}Running Processes:${NC}"
    
    # Check autossh
    local autossh_pid
    autossh_pid=$(pgrep -f "autossh" 2>/dev/null || true)
    if [ -n "$autossh_pid" ]; then
        status_ok "autossh is running (PID: $autossh_pid)"
    else
        status_fail "autossh is not running"
    fi
    
    # Check caffeinate
    local caffeinate_pid
    caffeinate_pid=$(pgrep -f "caffeinate.*autossh" 2>/dev/null || true)
    if [ -n "$caffeinate_pid" ]; then
        status_ok "caffeinate wrapper is running (PID: $caffeinate_pid)"
    else
        status_warn "caffeinate wrapper not found (sleep prevention may not be active)"
    fi
    
    # Check SSH tunnel connection
    local ssh_pid
    ssh_pid=$(pgrep -f "ssh.*-R.*localhost:22" 2>/dev/null || true)
    if [ -n "$ssh_pid" ]; then
        status_ok "SSH tunnel connection is active (PID: $ssh_pid)"
    else
        status_warn "SSH tunnel connection not detected (may still be establishing)"
    fi
    echo ""
}

check_tunnel_config() {
    echo -e "${BLUE}Tunnel Configuration:${NC}"
    
    if [ -f "$PLIST_PATH" ]; then
        # Extract remote host from plist
        local remote_info
        remote_info=$(grep -A1 "<string>-R</string>" "$PLIST_PATH" 2>/dev/null | tail -1 | sed 's/<[^>]*>//g' | tr -d ' ' || true)
        if [ -n "$remote_info" ]; then
            status_info "Tunnel binding: $remote_info"
        fi
        
        # Try to extract from the shell command version
        local cmd_line
        cmd_line=$(grep "caffeinate" "$PLIST_PATH" 2>/dev/null | sed 's/<[^>]*>//g' | tr -d ' ' || true)
        if [ -n "$cmd_line" ]; then
            local tunnel_port
            tunnel_port=$(echo "$cmd_line" | grep -oE '\-R [0-9]+:' | grep -oE '[0-9]+' || true)
            local remote_host
            remote_host=$(echo "$cmd_line" | grep -oE '[a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+$' || true)
            
            if [ -n "$tunnel_port" ]; then
                status_info "Tunnel port: $tunnel_port"
            fi
            if [ -n "$remote_host" ]; then
                status_info "Remote server: $remote_host"
            fi
        fi
    else
        status_warn "Cannot read configuration (plist not found)"
    fi
    echo ""
}

check_network() {
    echo -e "${BLUE}Network Status:${NC}"
    
    # Check if we have network connectivity
    if ping -c 1 -W 2 8.8.8.8 &>/dev/null; then
        status_ok "Internet connectivity: OK"
    else
        status_fail "Internet connectivity: FAILED"
    fi
    
    # Try to get remote host from plist and check connectivity
    if [ -f "$PLIST_PATH" ]; then
        local remote_host
        remote_host=$(grep -oE '[a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+' "$PLIST_PATH" 2>/dev/null | head -1 | cut -d'@' -f2 || true)
        if [ -n "$remote_host" ]; then
            if ping -c 1 -W 3 "$remote_host" &>/dev/null; then
                status_ok "Server reachable: $remote_host"
            else
                status_warn "Server ping failed: $remote_host (may be blocking ICMP)"
            fi
        fi
    fi
    echo ""
}

check_logs() {
    echo -e "${BLUE}Recent Logs:${NC}"
    
    if [ -f "$LOG_FILE" ]; then
        local log_lines
        log_lines=$(wc -l < "$LOG_FILE" | tr -d ' ')
        status_info "Log file: $LOG_FILE ($log_lines lines)"
        
        echo ""
        echo -e "  ${CYAN}Last $LOG_LINES lines of stdout:${NC}"
        tail -"$LOG_LINES" "$LOG_FILE" 2>/dev/null | sed 's/^/    /'
    else
        status_warn "No log file found at $LOG_FILE"
    fi
    
    echo ""
    
    if [ -f "$ERR_FILE" ]; then
        local err_lines
        err_lines=$(wc -l < "$ERR_FILE" | tr -d ' ')
        if [ "$err_lines" -gt 0 ]; then
            status_warn "Error log: $ERR_FILE ($err_lines lines)"
            echo ""
            echo -e "  ${CYAN}Last $LOG_LINES lines of stderr:${NC}"
            tail -"$LOG_LINES" "$ERR_FILE" 2>/dev/null | sed 's/^/    /'
        else
            status_ok "Error log is empty"
        fi
    else
        status_info "No error log file found"
    fi
    echo ""
}

print_troubleshooting() {
    if [ "$VERBOSE" = false ]; then
        return
    fi
    
    echo -e "${BLUE}Troubleshooting Commands:${NC}"
    echo ""
    echo "  Restart tunnel:"
    echo "    $(basename "$0") restart"
    echo ""
    echo "  Watch logs in real-time:"
    echo "    tail -f $LOG_FILE"
    echo ""
    echo "  Manual test (in foreground):"
    echo "    $(basename "$0") stop"
    echo "    # Then run the autossh command from plist manually"
    echo ""
    echo "  Check SSH connectivity to server:"
    echo "    ssh -v user@server 'echo OK'"
    echo ""
}

cmd_status_brief() {
    check_plist
    
    if is_running; then
        status_ok "Tunnel is running"
        
        # Show PIDs
        local autossh_pid
        autossh_pid=$(pgrep -f "autossh" 2>/dev/null || true)
        if [ -n "$autossh_pid" ]; then
            echo "  autossh PID: $autossh_pid"
        fi
    else
        status_fail "Tunnel is not running"
        exit 1
    fi
}

cmd_status() {
    # Parse status-specific options
    shift  # Remove 'status' from args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -l|--log-lines)
                LOG_LINES="$2"
                VERBOSE=true  # -l implies verbose
                shift 2
                ;;
            -h|--help)
                print_usage
                exit 0
                ;;
            *)
                echo -e "${RED}Error: Unknown option: $1${NC}" >&2
                echo "Use --help for usage information." >&2
                exit 1
                ;;
        esac
    done
    
    if [ "$VERBOSE" = false ]; then
        cmd_status_brief
        return
    fi
    
    print_header
    check_launchd_service
    check_processes
    check_tunnel_config
    check_network
    check_logs
    print_troubleshooting
}

#===============================================================================
# Main
#===============================================================================
main() {
    local command="${1:-}"
    
    case "$command" in
        start)
            cmd_start
            ;;
        stop)
            cmd_stop
            ;;
        restart)
            cmd_restart
            ;;
        status)
            cmd_status "$@"
            ;;
        -h|--help|help)
            print_usage
            ;;
        --version)
            echo "mole version $VERSION"
            ;;
        "")
            print_usage
            exit 1
            ;;
        *)
            echo -e "${RED}Error: Unknown command: $command${NC}" >&2
            echo "Use --help for usage information." >&2
            exit 1
            ;;
    esac
}

main "$@"
